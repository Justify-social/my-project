"use strict";
/**
 * Consolidated Icon Utilities
 * AUTO-GENERATED by update-icon-registry.mjs - last updated: 2025-04-02T21:04:13.644Z
 * Replaces multiple overlapping files with a single source of truth
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iconRegistry = exports.PLATFORM_ICON_MAP = exports.SEMANTIC_ICONS = void 0;
exports.normalizeIconName = normalizeIconName;
exports.getIconPath = getIconPath;
exports.iconExists = iconExists;
exports.getIconBaseName = getIconBaseName;
exports.getIconCacheKey = getIconCacheKey;
exports.toKebabCase = toKebabCase;
// IMPORTANT: The icon registry is the single source of truth for icons
const icon_registry_json_1 = __importDefault(require("../../../../../public/static/icon-registry.json"));
// Use canonical registry directly with type safety
const registry = icon_registry_json_1.default;
// Debug flag
const DEBUG = process.env.NODE_ENV === 'development';
// Helper for debug logging
const debug = (...args) => {
    if (DEBUG) {
        console.log('[Icons]', ...args);
    }
};
// Type-safe mapping from semantic names to technical names
// Type-safe mapping from semantic names to technical names
exports.SEMANTIC_ICONS = {
    "add": "faPlus",
    "delete": "faTrash",
    "edit": "faPen",
    "save": "faSave",
    "close": "faXmark",
    "check": "faCheck",
    "info": "faInfo",
    "warning": "faTriangleExclamation",
    "error": "faCircleXmark",
    "success": "faCircleCheck",
    "user": "faUser",
    "settings": "faGear",
    "search": "faMagnifyingGlass",
    "calendar": "faCalendar",
    "chevronRight": "faChevronRight",
    "chevronLeft": "faChevronLeft",
    "chevronUp": "faChevronUp",
    "chevronDown": "faChevronDown",
    "arrowRight": "faArrowRight",
    "arrowLeft": "faArrowLeft",
    "arrowUp": "faArrowUp",
    "arrowDown": "faArrowDown",
    "home": "faHome",
    "menu": "faBars",
    "bell": "faBell",
    "coins": "faCoins",
    "upload": "faUpload",
    "download": "faDownload",
    "copy": "faCopy",
    "more": "faEllipsisVertical",
    "link": "faLink",
    "play": "faPlay",
    "pause": "faPause",
    "stop": "faStop",
    "cog": "faGear",
    "times": "faXmark",
    "xmark": "faXmark",
    "xCircle": "faCircleXmark",
    "anglesLeft": "faAnglesLeft",
    "anglesRight": "faAnglesRight",
    "github": "faGithub",
    "spinner": "faCircleNotch",
    "circleNotch": "faSpinner",
    "folder": "faFolder",
    "chartLine": "faChartLine",
    "comment": "faComment",
    "palette": "faPalette"
};
// Map of icon styles to directory names
const STYLE_FOLDERS = {
    'solid': 'solid',
    'light': 'light',
    'regular': 'regular',
    'brand': 'brands'
};
// Platform icon map for social media icons
// Platform icon map for social media icons
exports.PLATFORM_ICON_MAP = {
    "facebook": "faFacebook",
    "instagram": "faInstagram",
    "linkedin": "faLinkedin",
    "tiktok": "faTiktok",
    "youtube": "faYoutube",
    "x": "faXTwitter"
};
// FontAwesome icon style prefixes for fallback generation
const FA_STYLE_PREFIXES = {
    'solid': 'fas',
    'light': 'fal',
    'regular': 'far',
    'brand': 'fab'
};
// Common FontAwesome icon alternatives when an exact match isn't found
// Common FontAwesome icon alternatives when an exact match isn't found
const FA_ICON_ALTERNATIVES = {
    "faCircleNotch": [
        "faSpinner",
        "faCircleNotch",
        "faSpinnerThird"
    ],
    "faSearch": [
        "faMagnifyingGlass",
        "faSearch"
    ],
    "faXmark": [
        "faXmark",
        "faTimes",
        "faClose"
    ],
    "faHome": [
        "faHome",
        "faHouse",
        "faHouseChimney"
    ],
    "faFolder": [
        "faFolder",
        "faFolderClosed"
    ],
    "faChartLine": [
        "faChartLine",
        "faChartSimple",
        "faLineChart"
    ],
    "faComment": [
        "faComment",
        "faCommentDots",
        "faMessage"
    ],
    "faCog": [
        "faGear",
        "faCog",
        "faSlidersH"
    ],
    "faCoins": [
        "faCoins",
        "faDollarSign",
        "faMoneyBill"
    ],
    "faBell": [
        "faBell",
        "faBellRing",
        "faNotification"
    ],
    "faPalette": [
        "faPalette",
        "faPaintBrush",
        "faFill"
    ]
};
// App-specific icons that should use the app directory
const APP_ICONS = [
    'creative-asset-testing',
    'brand-health',
    'brand-lift',
    'campaigns',
    'help',
    'home',
    'influencers',
    'mmm',
    'reports',
    'settings',
    'billing'
];
// Standard FontAwesome icons that shouldn't be in the app directory
const STANDARD_ICONS = [
    'profile-image',
    'magnifying-glass',
    'coins'
];
/**
 * Normalize icon names to handle various formats
 */
function normalizeIconName(name) {
    if (!name)
        return 'faQuestion';
    // Handle semantic names like 'add' -> 'faPlus'
    if (name in exports.SEMANTIC_ICONS) {
        return exports.SEMANTIC_ICONS[name];
    }
    // Handle platform names like 'facebook' -> 'faFacebook'
    if (name in exports.PLATFORM_ICON_MAP) {
        return exports.PLATFORM_ICON_MAP[name];
    }
    // App icon special handling - normalize app prefixed icons
    if (name.startsWith('app') || name.includes('app_') || name.includes('app-')) {
        // Strip any non-alphanumeric characters and standardize casing
        const cleanName = name.replace(/[^a-zA-Z0-9]/g, '');
        // Special case for MMM which should be appMMM not appMmm
        if (cleanName.toLowerCase() === 'appmmm') {
            return 'appMMM';
        }
        // Convert to proper camelCase with app prefix
        // First letter after 'app' should be uppercase
        if (cleanName.toLowerCase().startsWith('app')) {
            const appPrefix = 'app';
            const restOfName = cleanName.slice(3); // Remove 'app'
            if (restOfName.length > 0) {
                return appPrefix + restOfName.charAt(0).toUpperCase() + restOfName.slice(1);
            }
        }
    }
    // Convert hyphenated icon names (fa-xmark) to camelCase (faXmark)
    if (name.includes('-')) {
        // Extract prefix and icon name parts
        const parts = name.split('-');
        const prefix = parts[0];
        // Convert remaining parts to camelCase
        const iconName = parts.slice(1).map((part, index) => index > 0 ? part.charAt(0).toUpperCase() + part.slice(1) : part).join('');
        // Combine prefix with capitalized icon name
        return prefix + iconName.charAt(0).toUpperCase() + iconName.slice(1);
    }
    // Handle app icons with underscores (convert to camelCase if needed)
    if (name.includes('_')) {
        return name.replace(/_([a-z])/gi, (_, char) => char.toUpperCase());
    }
    // Add 'fa' prefix if missing and not app/kpis prefixed
    if (!name.startsWith('fa') && !name.startsWith('app') && !name.startsWith('kpis')) {
        return `fa${name.charAt(0).toUpperCase()}${name.slice(1)}`;
    }
    return name;
}
/**
 * Find an icon in the registry by its FontAwesome map name
 */
function findIconByMapName(mapName) {
    if (!registry?.icons || !Array.isArray(registry.icons)) {
        debug('Icon registry is not properly loaded or not an array');
        return null;
    }
    const icon = registry.icons.find((item) => item.map === mapName);
    debug(icon ? `Found icon by map name '${mapName}'` : `Icon '${mapName}' not found by map name`);
    return icon || null;
}
/**
 * Find an icon in the registry by its id
 */
function findIconById(id) {
    if (!registry?.icons || !Array.isArray(registry.icons)) {
        debug('Icon registry is not properly loaded or not an array');
        return null;
    }
    const kebabId = toKebabCase(id);
    const icon = registry.icons.find((item) => item.id === id ||
        item.id === `${id.toLowerCase()}` ||
        item.kebabId === kebabId);
    debug(icon ? `Found icon by ID '${id}'` : `Icon '${id}' not found by ID`);
    return icon || null;
}
/**
 * Try to find an icon by its alternatives if the primary name isn't found
 */
function findIconByAlternatives(name) {
    if (FA_ICON_ALTERNATIVES[name]) {
        for (const alt of FA_ICON_ALTERNATIVES[name]) {
            const iconByMap = findIconByMapName(alt);
            if (iconByMap)
                return iconByMap;
            const iconById = findIconById(alt);
            if (iconById)
                return iconById;
        }
    }
    return null;
}
/**
 * Generate a standardized FontAwesome icon path for fallback when not in registry
 *
 * This maintains the design system by using a predictable path based on naming conventions
 */
function generateFontAwesomeIconPath(name, variant = 'light') {
    // Remove 'fa' prefix to get the actual icon name
    const iconName = name.startsWith('fa') ? name.substring(2).toLowerCase() : name.toLowerCase();
    // Convert from camelCase to kebab-case
    const kebabName = toKebabCase(iconName);
    // Create the path using the style folder and kebab name
    const folder = STYLE_FOLDERS[variant] || 'light';
    return `/icons/${folder}/${kebabName}.svg`;
}
/**
 * Get icon path with proper error handling - uses ONLY the icon registry (SSOT)
 */
function getIconPath(name, variant = 'light') {
    try {
        // First normalize the icon name
        const normalizedName = normalizeIconName(name);
        debug(`Getting icon path for: ${name} -> normalized to: ${normalizedName}`);
        // First check if we can find the icon by its map name in the registry
        const iconByMap = findIconByMapName(normalizedName);
        if (iconByMap) {
            debug(`Icon found in registry by map name: ${normalizedName}`);
            if (normalizedName.startsWith('fa')) {
                // For FontAwesome icons, apply the requested variant unless it would conflict with the style
                const iconStyle = iconByMap.category;
                let folderName = STYLE_FOLDERS[variant] || 'light';
                // Handle cases where icon name implies specific style
                if (normalizedName.endsWith('Light') && folderName !== 'light') {
                    folderName = 'light'; // Force light variant for Light suffix icons
                }
                else if (!normalizedName.endsWith('Light') && iconStyle === 'solid' && variant !== 'light') {
                    folderName = 'solid'; // Use solid for non-Light icons when no specific style is requested
                }
                // Extract the clean filename from the path
                const pathParts = (iconByMap.path || '').split('/');
                const filename = pathParts[pathParts.length - 1];
                return `/icons/${folderName}/${filename}`;
            }
            // For app and kpi icons, use the exact path from registry
            return iconByMap.path || '/icons/light/question.svg';
        }
        // Also try finding by icon ID (as a fallback)
        const iconById = findIconById(normalizedName);
        if (iconById) {
            debug(`Icon found in registry by id: ${normalizedName}`);
            return iconById.path || '/icons/light/question.svg';
        }
        // If still not found, try alternative icon names
        const iconByAlternative = findIconByAlternatives(normalizedName);
        if (iconByAlternative) {
            debug(`Icon found by alternative name for '${normalizedName}'`);
            return iconByAlternative.path || '/icons/light/question.svg';
        }
        // Generate a path using FA naming conventions as a last resort
        if (normalizedName.startsWith('fa')) {
            const generatedPath = generateFontAwesomeIconPath(normalizedName, variant);
            debug(`Icon '${normalizedName}' (normalized to '${normalizedName}') not found in registry, using predicted path: ${generatedPath}`);
            return generatedPath;
        }
        debug(`Icon '${normalizedName}' (normalized to '${normalizedName}') not found in registry, using fallback`);
        return '/icons/light/question.svg';
    }
    catch (error) {
        console.error('Error getting icon path:', error);
        return '/icons/light/question.svg';
    }
}
/**
 * Check if an icon exists in the registry
 */
function iconExists(name) {
    const normalizedName = normalizeIconName(name);
    // Check by map name
    const iconByMap = findIconByMapName(normalizedName);
    if (iconByMap)
        return true;
    // Check by ID
    const iconById = findIconById(normalizedName);
    if (iconById)
        return true;
    // Check by alternatives
    const iconByAlternative = findIconByAlternatives(normalizedName);
    if (iconByAlternative)
        return true;
    return false;
}
/**
 * Get the base name of an icon without fa/fas/far prefix
 */
function getIconBaseName(name) {
    const normalizedName = normalizeIconName(name);
    if (normalizedName.startsWith('fa')) {
        // Remove fa prefix
        return normalizedName.substring(2);
    }
    return normalizedName;
}
/**
 * Generate a cache key for an icon to use in memoization
 */
function getIconCacheKey(name, variant = 'light') {
    return `${normalizeIconName(name)}_${variant}`;
}
/**
 * Convert a string to kebab-case
 */
function toKebabCase(str) {
    return str
        // Replace uppercase letters with - followed by lowercase letter
        .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
        .toLowerCase();
}
/**
 * Export the registry to allow direct access without reimporting
 */
exports.iconRegistry = registry;
