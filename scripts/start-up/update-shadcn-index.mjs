#!/usr/bin/env node

/**
 * Shadcn Index File Generator
 * 
 * This script generates or updates index.ts files for shadcn UI components.
 * It ensures that all component exports are properly available through index files,
 * making imports cleaner and more consistent.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { glob } from 'glob';

// Configuration
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '..');
const UI_DIR = path.join(ROOT_DIR, 'src', 'components', 'ui');
const COMPONENT_TYPES = ['atoms', 'molecules', 'organisms'];

// ANSI colors for console output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

/**
 * Generate an index.ts file for a component directory
 */
async function generateComponentIndex(componentDir) {
  // Skip if directory doesn't exist
  if (!fs.existsSync(componentDir)) {
    return false;
  }

  const files = fs.readdirSync(componentDir);
  
  // Skip if it's just a single file and not a directory
  if (files.every(file => !fs.statSync(path.join(componentDir, file)).isDirectory())) {
    return false;
  }
  
  // If there's already an index.ts file, read its content
  const indexPath = path.join(componentDir, 'index.ts');
  let existingContent = '';
  if (fs.existsSync(indexPath)) {
    existingContent = fs.readFileSync(indexPath, 'utf8');
  }
  
  // Find component files (TypeScript/JavaScript)
  const componentFiles = files.filter(file => {
    const filePath = path.join(componentDir, file);
    return fs.statSync(filePath).isFile() && 
      (file.endsWith('.tsx') || file.endsWith('.jsx') || file.endsWith('.ts') || file.endsWith('.js')) &&
      !file.includes('.test.') &&
      !file.includes('.spec.') &&
      file !== 'index.ts' &&
      file !== 'index.js';
  });

  // Skip if no component files found
  if (componentFiles.length === 0) {
    return false;
  }
  
  // Generate new index.ts content
  let newContent = '/**\n * Index file for component exports\n * Generated by update-shadcn-index.mjs\n */\n\n';
  
  for (const file of componentFiles) {
    const baseName = path.basename(file, path.extname(file));
    newContent += `export * from './${baseName}';\n`;
  }
  
  // Check for subdirectories that might have components
  const subdirs = files.filter(file => {
    const filePath = path.join(componentDir, file);
    return fs.statSync(filePath).isDirectory() && !file.startsWith('.');
  });
  
  for (const subdir of subdirs) {
    // Check if the subdirectory has an index.ts
    const subdirIndexPath = path.join(componentDir, subdir, 'index.ts');
    if (fs.existsSync(subdirIndexPath)) {
      newContent += `export * from './${subdir}';\n`;
    }
  }
  
  // Only write if content is different
  if (newContent !== existingContent) {
    fs.writeFileSync(indexPath, newContent);
    return true;
  }
  
  return false;
}

/**
 * Generate index.ts files for all component directories
 */
async function generateAllComponentIndexes() {
  console.log(`${colors.cyan}Updating Shadcn component index files...${colors.reset}`);
  
  let updatedCount = 0;
  
  // Process each component category (atoms, molecules, organisms)
  for (const type of COMPONENT_TYPES) {
    const categoryDir = path.join(UI_DIR, type);
    
    if (!fs.existsSync(categoryDir)) {
      console.warn(`${colors.yellow}Component category not found: ${type}${colors.reset}`);
      continue;
    }
    
    // Get all component directories
    const entries = fs.readdirSync(categoryDir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const componentDir = path.join(categoryDir, entry.name);
        const updated = await generateComponentIndex(componentDir);
        if (updated) {
          updatedCount++;
          console.log(`${colors.green}✓ Updated index for ${type}/${entry.name}${colors.reset}`);
        }
      }
    }
    
    // Also generate an index.ts for the category itself
    const categoryIndexPath = path.join(categoryDir, 'index.ts');
    let categoryContent = '/**\n * Index file for component category exports\n * Generated by update-shadcn-index.mjs\n */\n\n';
    
    // Get all component subdirectories that have index.ts files
    const componentDirs = entries
      .filter(entry => entry.isDirectory())
      .map(entry => entry.name)
      .filter(name => fs.existsSync(path.join(categoryDir, name, 'index.ts')));
    
    for (const dir of componentDirs) {
      categoryContent += `export * from './${dir}';\n`;
    }
    
    // Only write if the file doesn't exist or the content is different
    let existingCategoryContent = '';
    if (fs.existsSync(categoryIndexPath)) {
      existingCategoryContent = fs.readFileSync(categoryIndexPath, 'utf8');
    }
    
    if (categoryContent !== existingCategoryContent) {
      fs.writeFileSync(categoryIndexPath, categoryContent);
      updatedCount++;
      console.log(`${colors.green}✓ Updated index for ${type}${colors.reset}`);
    }
  }
  
  console.log(`${colors.cyan}Index update complete: ${updatedCount} files updated${colors.reset}`);
  return updatedCount > 0;
}

// Main execution
try {
  await generateAllComponentIndexes();
  process.exit(0);
} catch (error) {
  console.error(`${colors.red}Error updating component indexes: ${error.message}${colors.reset}`);
  console.error(error);
  process.exit(1);
} 