#!/usr/bin/env node

/**
 * Backup File Removal Tool
 * 
 * This script safely removes backup files identified by find-backups.js.
 * It can work either from a JSON report or from patterns.
 * 
 * Usage:
 *   node scripts/cleanup/remove-backups.js [--dry-run] [--from-report=<json-file>] [--patterns-only]
 * 
 * Options:
 *   --dry-run         Show what would be deleted without actually removing files
 *   --from-report=<f> Use a JSON report generated by find-backups.js with the --json flag
 *   --patterns-only   Only remove files matching known backup patterns, skip duplicates
 *   --duplicates-only Only remove duplicate files, skip backup pattern files
 *   --no-confirm      Skip confirmation prompt (use with caution!)
 */

import fs from 'fs';
import path from 'path';
import readline from 'readline';

// Color console output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Parse command line arguments
const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');
const patternsOnly = args.includes('--patterns-only');
const duplicatesOnly = args.includes('--duplicates-only');
const noConfirm = args.includes('--no-confirm');
const reportArg = args.find(arg => arg.startsWith('--from-report='));
const reportFile = reportArg ? reportArg.replace('--from-report=', '') : null;

// The same backup patterns used in find-backups.js
const backupPatterns = [
  /\.bak$/i,
  /\.backup$/i,
  /\.old$/i,
  /\.deprecated$/i,
  /\.unused$/i,
  /\.legacy$/i,
  /\.copy$/i,
  /\.tmp$/i,
  /\~$/,
  /\.\d+$/,
  /\.orig$/i,
  /-backup\./i,
  /\.back$/i,
  /\.sav$/i,
  /\.save$/i,
  /\.archive$/i,
  /\.prev$/i,
  /^backup-/i,
  /\.backup\./i
];

// Directories to ignore
const ignoreDirectories = [
  'node_modules',
  '.git',
  'dist',
  'build',
  'coverage',
  '.next',
  '.vercel',
  '.github',
  '.husky',
  '.vscode',
  '.idea'
];

// Statistics
const stats = {
  backupFilesRemoved: 0,
  duplicateFilesRemoved: 0,
  emptyDirectoriesRemoved: 0,
  totalBytesRecovered: 0,
  errors: 0
};

/**
 * Formats a file size in readable format
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted file size
 */
function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' bytes';
  else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
  else if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
  else return (bytes / 1073741824).toFixed(2) + ' GB';
}

/**
 * Checks if a file matches any backup patterns
 * @param {string} fileName - Name of the file
 * @returns {boolean} True if the file matches a backup pattern
 */
function isBackupFile(fileName) {
  return backupPatterns.some(pattern => pattern.test(fileName));
}

/**
 * Checks if a directory should be ignored
 * @param {string} dirPath - Path to the directory
 * @returns {boolean} True if the directory should be ignored
 */
function shouldIgnoreDirectory(dirPath) {
  const dirName = path.basename(dirPath);
  return ignoreDirectories.includes(dirName);
}

/**
 * Safely removes a file and updates statistics
 * @param {string} filePath - Path to the file to remove
 * @param {string} fileType - Type of file ('backup' or 'duplicate')
 * @param {number} fileSize - Size of the file in bytes
 * @returns {boolean} True if the file was removed successfully
 */
function safelyRemoveFile(filePath, fileType, fileSize) {
  try {
    if (!fs.existsSync(filePath)) {
      console.log(`${colors.yellow}File does not exist: ${filePath}${colors.reset}`);
      return false;
    }
    
    if (isDryRun) {
      console.log(`${colors.yellow}Would remove ${fileType}: ${filePath}${colors.reset}`);
      
      if (fileType === 'backup') {
        stats.backupFilesRemoved++;
      } else {
        stats.duplicateFilesRemoved++;
      }
      
      stats.totalBytesRecovered += fileSize;
      return true;
    } else {
      fs.unlinkSync(filePath);
      console.log(`${colors.green}Removed ${fileType}: ${filePath}${colors.reset}`);
      
      if (fileType === 'backup') {
        stats.backupFilesRemoved++;
      } else {
        stats.duplicateFilesRemoved++;
      }
      
      stats.totalBytesRecovered += fileSize;
      return true;
    }
  } catch (err) {
    console.error(`${colors.red}Error removing file ${filePath}: ${err.message}${colors.reset}`);
    stats.errors++;
    return false;
  }
}

/**
 * Safely removes an empty directory
 * @param {string} dirPath - Path to the directory
 * @returns {boolean} True if the directory was removed successfully
 */
function safelyRemoveDirectory(dirPath) {
  try {
    if (!fs.existsSync(dirPath)) {
      return false;
    }
    
    // Double-check that directory is empty
    const files = fs.readdirSync(dirPath);
    if (files.length > 0) {
      return false;
    }
    
    if (isDryRun) {
      console.log(`${colors.yellow}Would remove empty directory: ${dirPath}${colors.reset}`);
      stats.emptyDirectoriesRemoved++;
      return true;
    } else {
      fs.rmdirSync(dirPath);
      console.log(`${colors.green}Removed empty directory: ${dirPath}${colors.reset}`);
      stats.emptyDirectoriesRemoved++;
      return true;
    }
  } catch (err) {
    console.error(`${colors.red}Error removing directory ${dirPath}: ${err.message}${colors.reset}`);
    stats.errors++;
    return false;
  }
}

/**
 * Removes backup files by scanning the directory
 * @param {string} dirPath - Directory to scan
 */
function removeBackupsByScanning(dirPath) {
  try {
    // Check if directory should be ignored
    if (shouldIgnoreDirectory(dirPath)) {
      return;
    }
    
    const files = fs.readdirSync(dirPath);
    let hadFiles = false;
    
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      
      try {
        const stats = fs.statSync(filePath);
        
        if (stats.isDirectory()) {
          // Recursively scan subdirectories
          removeBackupsByScanning(filePath);
        } else if (stats.isFile()) {
          hadFiles = true;
          
          // Check for backup files
          if (!if (duplicatesOnly) isBackupFile(file)) {
            safelyRemoveFile(filePath, 'backup', stats.size);
          }
        }
      } catch (err) {
        console.error(`${colors.red}Error processing ${filePath}: ${err.message}${colors.reset}`);
      }
    }
    
    // Check if directory is now empty (after removing files)
    if (!isDryRun && hadFiles) {
      try {
        const remainingFiles = fs.readdirSync(dirPath);
        if (remainingFiles.length === 0) {
          safelyRemoveDirectory(dirPath);
        }
      } catch (err) {
        // Ignore errors when checking if directory is empty
      }
    }
  } catch (err) {
    console.error(`${colors.red}Error scanning directory ${dirPath}: ${err.message}${colors.reset}`);
  }
}

/**
 * Removes files based on a JSON report
 * @param {string} reportFilePath - Path to the JSON report file
 */
function removeFilesFromReport(reportFilePath) {
  try {
    const reportData = JSON.parse(fs.readFileSync(reportFilePath, 'utf8'));
    
    // Remove backup files
    if (!duplicatesOnly && reportData.backupFiles) {
      console.log(`\n${colors.cyan}Removing Backup Files${colors.reset}`);
      console.log(`${colors.cyan}================================${colors.reset}`);
      
      for (const backupFile of reportData.backupFiles) {
        safelyRemoveFile(backupFile.path, 'backup', backupFile.size);
      }
    }
    
    // Remove duplicate files
    if (!patternsOnly && reportData.duplicateFiles) {
      console.log(`\n${colors.cyan}Removing Duplicate Files${colors.reset}`);
      console.log(`${colors.cyan}================================${colors.reset}`);
      
      for (const duplicateSet of reportData.duplicateFiles) {
        // Keep the original file, remove all duplicates
        console.log(`${colors.blue}Keeping original: ${duplicateSet.original.path}${colors.reset}`);
        
        for (const duplicate of duplicateSet.duplicates) {
          safelyRemoveFile(duplicate.path, 'duplicate', duplicate.size);
        }
      }
    }
    
    // Remove empty directories
    if (reportData.emptyDirectories) {
      console.log(`\n${colors.cyan}Removing Empty Directories${colors.reset}`);
      console.log(`${colors.cyan}================================${colors.reset}`);
      
      for (const dirPath of reportData.emptyDirectories) {
        safelyRemoveDirectory(dirPath);
      }
    }
  } catch (err) {
    console.error(`${colors.red}Error processing report file: ${err.message}${colors.reset}`);
    process.exit(1);
  }
}

/**
 * Prints a summary of the removal operation
 */
function printSummary() {
  console.log(`\n${colors.cyan}Cleanup Summary${colors.reset}`);
  console.log(`${colors.cyan}================================${colors.reset}`);
  console.log(`Backup files removed: ${stats.backupFilesRemoved}`);
  console.log(`Duplicate files removed: ${stats.duplicateFilesRemoved}`);
  console.log(`Empty directories removed: ${stats.emptyDirectoriesRemoved}`);
  console.log(`Total space recovered: ${formatFileSize(stats.totalBytesRecovered)}`);
  console.log(`Errors encountered: ${stats.errors}`);
  
  if (isDryRun) {
    console.log(`\n${colors.yellow}This was a dry run. No files were actually removed.${colors.reset}`);
    console.log(`To actually remove the files, run without the --dry-run flag.`);
  } else {
    console.log(`\n${colors.green}Cleanup complete!${colors.reset}`);
  }
  
  console.log(`\n${colors.magenta}Next Steps${colors.reset}`);
  console.log(`1. Update unification.md with the cleanup results`);
  console.log(`2. Run a build to ensure everything still works correctly`);
  console.log(`3. Consider implementing regular cleanup via CI/CD`);
}

/**
 * Creates a confirmation prompt
 * @returns {Promise<boolean>} Promise resolving to user's confirmation choice
 */
function confirmAction() {
  return new Promise((resolve) => {
    if (noConfirm) {
      resolve(true);
      return;
    }
    
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    const message = isDryRun
      ? 'This is a dry run, no files will be removed. Continue? (y/n): '
      : `${colors.red}WARNING: This will permanently remove files from your system. Continue? (y/n): ${colors.reset}`;
    
    rl.question(message, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

/**
 * Main function
 */
async function main() {
  console.log(`${colors.cyan}=====================================${colors.reset}`);
  console.log(`${colors.cyan}Backup File Removal Tool${colors.reset}`);
  console.log(`${colors.cyan}=====================================${colors.reset}`);
  console.log(`Mode: ${isDryRun ? 'Dry run' : 'Live'}`);
  
  if (patternsOnly) {
    console.log('Target: Backup pattern files only');
  } else if (duplicatesOnly) {
    console.log('Target: Duplicate files only');
  } else {
    console.log('Target: All backup and duplicate files');
  }
  
  // Get user confirmation
  const confirmed = await confirmAction();
  if (!confirmed) {
    console.log('Operation cancelled.');
    process.exit(0);
  }
  
  if (reportFile) {
    // Remove files based on JSON report
    console.log(`Using report file: ${reportFile}`);
    removeFilesFromReport(reportFile);
  } else {
    // Scan and remove files
    console.log('Scanning for backup files...');
    removeBackupsByScanning(process.cwd());
  }
  
  // Print summary
  printSummary();
}

// Run the main function
main().catch(err => {
  console.error(`${colors.red}Unhandled error: ${err.message}${colors.reset}`);
  process.exit(1);
}); 