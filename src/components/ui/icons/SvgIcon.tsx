'use client';

import React, { useMemo } from 'react';
import { cn } from '@/lib/utils';
import Image from 'next/image';

// This type will be created when icon-data.ts is generated
// For now we're using a placeholder until the scripts are run
type IconName = string;

// Size variants for the icon
type IconSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl';

// Platform names for social icons
type PlatformName = 'facebook' | 'instagram' | 'linkedin' | 'tiktok' | 'youtube' | 'x';

// Map of icon prefixes to style folders
const ICON_STYLE_FOLDERS = {
  'fas': 'solid',
  'fal': 'light',
  'fab': 'brands',
  'far': 'regular'
};

export interface SvgIconProps {
  /**
   * Name of the icon to display
   */
  name: IconName;
  
  /**
   * CSS class names to apply to the icon
   */
  className?: string;
  
  /**
   * Size variant of the icon
   */
  size?: IconSize;
  
  /**
   * Optional title for accessibility
   */
  title?: string;

  /**
   * Click handler for the icon
   */
  onClick?: (e: React.MouseEvent<SVGElement>) => void;
  
  /**
   * Whether to apply a spin animation to the icon
   */
  spin?: boolean;
  
  /**
   * Whether to apply a pulse animation to the icon
   */
  pulse?: boolean;
  
  /**
   * Whether the icon should be flipped horizontally
   */
  flipHorizontal?: boolean;
  
  /**
   * Whether the icon should be flipped vertically
   */
  flipVertical?: boolean;
  
  /**
   * Degree rotation for the icon (0-360)
   */
  rotation?: 0 | 90 | 180 | 270;

  /**
   * Icon style (solid, light, etc) - by default uses the style from the icon prefix
   */
  style?: 'solid' | 'light' | 'brands' | 'regular';
  
  /**
   * Whether to use solid variant of the icon (alternative to style='solid')
   */
  solid?: boolean;
  
  /**
   * Whether the icon is in active state
   */
  active?: boolean;
  
  /**
   * Type of icon (button or static) - affects hover behavior
   */
  iconType?: 'button' | 'static';
  
  /**
   * Action type of the icon - affects hover color
   */
  action?: 'default' | 'delete' | 'warning' | 'success';
  
  // Allow any other props to be passed through to the SVG element
  [key: string]: any;
}

export interface PlatformIconProps {
  /**
   * Name of the platform
   */
  platformName: PlatformName;
  
  /**
   * CSS class names to apply to the icon
   */
  className?: string;
  
  /**
   * Size variant of the icon
   */
  size?: IconSize;
  
  /**
   * Click handler for the icon
   */
  onClick?: (e: React.MouseEvent<SVGElement>) => void;
}

/**
 * Map of icon sizes to Tailwind CSS classes
 */
const SIZE_CLASSES: Record<IconSize, string> = {
  'xs': 'w-3 h-3',
  'sm': 'w-4 h-4',
  'md': 'w-5 h-5',
  'lg': 'w-6 h-6',
  'xl': 'w-8 h-8',
  '2xl': 'w-10 h-10',
  '3xl': 'w-12 h-12',
  '4xl': 'w-16 h-16',
};

/**
 * Map of platform names to their corresponding icon names
 */
const PLATFORM_ICON_MAP: Record<PlatformName, IconName> = {
  'facebook': 'faFacebook',
  'instagram': 'faInstagram',
  'linkedin': 'faLinkedin',
  'tiktok': 'faTiktok',
  'youtube': 'faYoutube',
  'x': 'faXTwitter',
} as const;

// We'll try to dynamically import the icon data when the script generates it
let iconData: Record<string, { 
  width: number; 
  height: number; 
  path: string; 
  url: string;
  prefix?: string; // Add prefix as it might come from the registry
  name?: string;
}> = {};

// This will be filled after running the icon scripts
try {
  // When icon-data.ts exists, this will work
  // @ts-ignore - This file will be generated by the scripts
  const importedData = require('./icon-data');
  iconData = importedData.iconData || {};
} catch (e) {
  // If the import fails, we'll use direct file access instead
  console.warn('Icon data not found. Run the icon generation scripts or icons will be loaded from files.');
}

/**
 * Extracts the base name of an icon without the fa prefix
 */
function getIconBaseName(fullName: string): string {
  // Handle undefined or empty name
  if (!fullName) {
    return 'question'; // Default to question icon as fallback
  }
  
  // Handle special Light icon case - remove Light suffix
  const nameWithoutLightSuffix = fullName.replace(/Light$/, '');
  
  // Convert e.g. faUserCircle to user-circle
  const baseName = nameWithoutLightSuffix.replace(/^fa/, '').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  return baseName;
}

/**
 * Extracts the prefix/style of an icon
 */
function getIconPrefix(fullName: string): string {
  // If name is undefined or empty, return default prefix
  if (!fullName) {
    return 'fas'; // Default to solid as a fallback
  }
  
  // Special case for Light icons
  if (fullName.endsWith('Light')) {
    return 'fal'; // Light icons
  }
  
  // Check if it's a social media icon
  const socialIcons = ['faFacebook', 'faInstagram', 'faLinkedin', 'faTiktok', 'faYoutube', 'faXTwitter', 'faTwitter', 'faGithub', 'faReddit', 'faPinterest'];
  if (socialIcons.includes(fullName)) {
    return 'fab'; // Brand icons
  }
  
  // For imported icons like faUser, we get the prefix from icon data or default to 'fas' (solid)
  return (iconData[fullName]?.prefix || 'fas');
}

/**
 * A modern SVG icon component that supports:
 * 1. Light vs Solid styles with hover effects 
 * 2. Different action colors (blue, red, yellow, green)
 * 3. Platform-specific icons
 */
export const SvgIcon = React.forwardRef<SVGSVGElement, SvgIconProps>(({
  name,
  platformName,
  size = 'md',
  className = '',
  color,
  iconType = 'static',
  active = false,
  solid = false,
  style,
  title,
  explicitStyle,
  action = 'default',
  onClick,
  ...rest
}, ref) => {
  // Get the icon prefix (fa, ri, etc.) for style mapping
  const prefix = getIconPrefix(name || '');
  
  // For button icons that should change on hover, we use different logic
  // static icons: use solid if specified, otherwise use the default prefix mapping
  // button icons: use light by default (unless solid is specified) and rely on hover for solid
  const usesSolidStyle = solid || active;
  
  // Determine style based on name suffix, explicit style, or defaults
  let styleName = explicitStyle;
  if (!styleName) {
    if (name?.endsWith('Light')) {
      styleName = 'light';
    } else if (usesSolidStyle) {
      styleName = 'solid';
    } else {
      // Use the mapped style or default to light for button icons and solid for static icons
      if (iconType === 'button' && !active) {
        styleName = 'light';  // Button icons default to light unless active
      } else {
        styleName = ICON_STYLE_FOLDERS[prefix as keyof typeof ICON_STYLE_FOLDERS] || 'solid';
      }
    }
  }
  
  // Remove Light suffix to get base name
  const nameWithoutSuffix = name?.replace(/Light$/, '') || '';
  const iconBaseName = getIconBaseName(nameWithoutSuffix);
  
  // For button icons that should show solid on hover, we'll need both light and solid
  const shouldUseHoverEffect = iconType === 'button' && !active && !solid;
  
  // Create the URL for the icon SVG
  const iconUrl = `/ui-icons/${styleName}/${iconBaseName}.svg`;
  
  // URL for the hover state (solid version)
  const hoverIconUrl = shouldUseHoverEffect ? 
    `/ui-icons/solid/${iconBaseName}.svg` : undefined;

  // Get hover effect classes based on icon type and action
  const getHoverClasses = () => {
    if (iconType === 'static' || active) return '';
    
    const actionColors: Record<string, string> = {
      default: 'group-hover:text-[#00BFFF]', // Deep Sky Blue
      delete: 'group-hover:text-red-600',
      warning: 'group-hover:text-yellow-500',
      success: 'group-hover:text-green-600'
    };
    
    return `transition-colors duration-200 ${actionColors[action as keyof typeof actionColors] || actionColors.default}`;
  };
  
  const hoverClasses = getHoverClasses();

  // Build transformation CSS classes
  const transformClasses = useMemo(() => {
    return [
      // Add transformation classes if needed - spin, flip, etc. can be added here
    ].filter(Boolean).join(' ');
  }, []);

  // If we have embedded data, use it
  if (iconData[name]) {
    const { width, height, path, url } = iconData[name];
    
    // Get the corresponding solid icon name for hover effects
    let hoverName: string | undefined;
    if (shouldUseHoverEffect) {
      if (name.endsWith('Light')) {
        // For Light icons, remove the Light suffix to get the solid version
        hoverName = name.replace(/Light$/, '');
      } else {
        // For non-Light icons, try to find a solid version if it exists
        const solidName = `fa${getIconBaseName(name)}`;
        hoverName = iconData[solidName] ? solidName : undefined;
      }
    }
    
    const hoverIconData = hoverName && iconData[hoverName];

    return (
      <span 
        className={cn(
          'inline-block relative',
          SIZE_CLASSES[size as keyof typeof SIZE_CLASSES],
          className
        )} 
        aria-hidden={!title}
        {...rest}
      >
        {/* Base icon */}
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          viewBox={`0 0 ${width} ${height}`}
          fill="currentColor"
          className={cn('w-full h-full', transformClasses, hoverClasses, shouldUseHoverEffect && 'group-hover:opacity-0')}
          onClick={onClick}
          ref={ref}
        >
          {title && <title>{title}</title>}
          <path d={path} />
        </svg>

        {/* Hover icon (solid version) */}
        {shouldUseHoverEffect && hoverIconData && (
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            viewBox={`0 0 ${hoverIconData.width} ${hoverIconData.height}`}
            fill="currentColor"
            className={cn('w-full h-full absolute inset-0 opacity-0 group-hover:opacity-100', transformClasses, hoverClasses)}
            onClick={onClick}
          >
            {title && <title>{title}</title>}
            <path d={hoverIconData.path} />
          </svg>
        )}
      </span>
    );
  }

  // Fallback to loading the SVG file directly
  return (
    <span 
      className={cn(
        'inline-flex shrink-0 relative',
        SIZE_CLASSES[size as keyof typeof SIZE_CLASSES],
        className
      )} 
      aria-hidden={!title}
      {...rest}
    >
      {/* Base icon (light) */}
      <img 
        src={iconUrl}
        alt={title || `${name} icon`}
        className={cn(
          'w-full h-full', 
          transformClasses, 
          shouldUseHoverEffect && 'group-hover:opacity-0 transition-opacity duration-200'
        )}
        style={{ 
          pointerEvents: rest.onClick ? 'auto' : 'none',
          objectFit: 'contain' 
        }}
        onClick={rest.onClick as any}
        title={title}
      />
      
      {/* Hover icon (solid version) */}
      {shouldUseHoverEffect && hoverIconUrl && (
        <img
          src={hoverIconUrl}
          alt={title || `${name} solid icon`}
          className={cn(
            'w-full h-full absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200', 
            transformClasses
          )}
          style={{ 
            pointerEvents: rest.onClick ? 'auto' : 'none',
            objectFit: 'contain' 
          }}
          onClick={rest.onClick as any}
          title={title}
        />
      )}
    </span>
  );
});

SvgIcon.displayName = 'SvgIcon';

/**
 * Platform Icon component - convenience wrapper for social media icons
 */
export function PlatformIcon({
  platformName,
  className,
  size = 'md',
  onClick,
}: PlatformIconProps) {
  // Convert platform name to corresponding icon name
  const iconName = PLATFORM_ICON_MAP[platformName];
  
  if (!iconName) {
    console.warn(`Unknown platform name: ${platformName}`);
    return null;
  }
  
  return (
    <SvgIcon
      name={iconName}
      className={className}
      size={size}
      onClick={onClick}
    />
  );
}

/**
 * This is a drop-in replacement for the FontAwesome-based Icon component.
 * Uses local SVG files for maximum reliability.
 */
export const Icon = SvgIcon; 